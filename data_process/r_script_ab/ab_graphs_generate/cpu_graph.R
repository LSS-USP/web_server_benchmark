# Convert date string and concatenate it with time to make possible the
# conversion from string to POSIX date time
# @param date String date in the format 'YYYYMMDD'
# @param time Time in the formate 'HH:MM:SS'
# @return List of POSIX date
date_time_to_posix <- function(date, time)
{
  year <- substring(date, 1, 4)
  mounth <- substring(date, 5, 6)
  day <- substring(date, 7, 9)

  date <- paste(year, mounth, day, sep='-')
  string_to_convert <- paste(date, time)

  posix_date <- as.POSIXct(string_to_convert)

  return(posix_date)
}

# Read raw data generated by collectl and separate it by cores. All of this
# work is returned as a single list contained the date/time and each core data.
# @param path_origin Path to raw data generated by collectl related with CPU
# @return Return a list, with the following informations: date, time, and coreX
#         X can vary based on CPU cores.
load_cpu_data <- function(path_origin)
{
    # Read all file
    raw_data <- read.table(path_origin)

    # Separate time information
    time_column <- raw_data[ ,1:2]
    time_column <- setNames(time_column, c('Date', 'Time'))
    posix_date <- date_time_to_posix(time_column$Date, time_column$Time)
    posix_date <- setNames(posix_date, c('PosixDate'))

    # Separate CPU information, this is a dynamic operation because we don't
    # know in advance the number of cores
    total_column <- ncol(raw_data)
    # Note: Following two considerations about fixed numbers below
    # - 2 because Date and Time was already extracted
    # - 12 is the total of information provided about CPU in collectl
    cpu_colums <- total_column - 2
    start_cpu_info <- seq(3, cpu_colums, by=12)
    cpu_label <- c('User', 'Nice', 'Sys', 'Wait', 'Irq', 'Soft', 'Steal',
                   'Idle', 'Totl', 'Guest', 'GuestN', 'Intrpt')
    core <- 1
    cpu_cores = vector(mode="list")
    for (cpu_set in start_cpu_info)
    {
      stop_in <- cpu_set + 11
      cpu_info <- raw_data[ ,cpu_set:stop_in]
      cpu_info <- setNames(cpu_info, cpu_label)
      cpu_cores[[core]] <- cpu_info
      core <- core + 1
    }
    # The last field of cpu_cores keeps the information about date and time
    cpu_cores[[core]] <- posix_date
    return (cpu_cores)
}

plot_cpu_utilization <- function(cpu_cores)
{
  total_elements <- length(cpu_cores)
  xlabel <- 'Time'
  ylabel <- 'Utilization (%)'
  position <- 1
  for (element in cpu_cores)
  {
    # Note: The last element of cpu_core it is date and time.
    plot(cpu_cores[[total_elements]], 100 - cpu_cores[[position]]$Idle,
          type='l', ylim=y, col='blue', cex.lab=1.5, lty=1, ylab=ylabel,
          xlab=xlabel, xaxt='n')
    position <- position + 1
  }
}

# Read arguments
#pathsArguments <- commandArgs(trailingOnly=TRUE)
#
## Test if there three argument. If not, return an error.
#if (length(pathsArguments) < 4)
#{
#  stop('You have to supply the path for each mpm strategy')
#} else if (length(pathsArguments) == 4)
#{
#  # default output file
#  origin <- pathsArguments[1]
#  destin <- pathsArguments[2]
#}
