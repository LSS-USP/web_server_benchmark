# Convert date string and concatenate it with time to make possible the
# conversion from string to POSIX date time
# @param date String date in the format 'YYYYMMDD'
# @param time Time in the formate 'HH:MM:SS'
# @return List of POSIX date
date_time_to_posix <- function(date, time)
{
  year <- substring(date, 1, 4)
  mounth <- substring(date, 5, 6)
  day <- substring(date, 7, 9)

  date <- paste(year, mounth, day, sep='-')
  string_to_convert <- paste(date, time)

  posix_date <- as.POSIXct(string_to_convert)

  return(posix_date)
}

# Read raw data generated by collectl and separate it by cores. All of this
# work is returned as a single list contained the date/time and each core data.
# @param path_origin Path to raw data generated by collectl related with CPU
# @return Return a list, with the following informations: date, time, and coreX
#         X can vary based on CPU cores.
load_cpu_data <- function(path_origin)
{
    # Read all file
    raw_data <- read.table(path_origin)

    # Separate time information
    time_column <- raw_data[ ,1:2]
    time_column <- setNames(time_column, c('Date', 'Time'))
    posix_date <- date_time_to_posix(time_column$Date, time_column$Time)
    posix_date <- setNames(posix_date, c('PosixDate'))

    # Separate CPU information, this is a dynamic operation because we don't
    # know in advance the number of cores
    total_column <- ncol(raw_data)
    # Note: Following two considerations about fixed numbers below
    # - 2 because Date and Time was already extracted
    # - 12 is the total of information provided about CPU in collectl
    cpu_colums <- total_column - 2
    start_cpu_info <- seq(3, cpu_colums, by=12)
    cpu_label <- c('User', 'Nice', 'Sys', 'Wait', 'Irq', 'Soft', 'Steal',
                   'Idle', 'Totl', 'Guest', 'GuestN', 'Intrpt')
    core <- 1
    cpu_cores = vector(mode="list")
    for (cpu_set in start_cpu_info)
    {
      stop_in <- cpu_set + 11
      cpu_info <- raw_data[ ,cpu_set:stop_in]
      cpu_info <- setNames(cpu_info, cpu_label)
      cpu_cores[[core]] <- cpu_info
      core <- core + 1
    }
    # The last field of cpu_cores keeps the information about date and time
    cpu_cores[[core]] <- posix_date
    return (cpu_cores)
}

# Plot CPU utilization, it has one line for each core.
# @param cpu_cores data structure generated by load_cpu_data
# @param destin Save image to
plot_cpu_utilization <- function(cpu_cores, destin)
{
  # Setups
  margin <- c(5.1, 8.5, 2, 2)
  png(destin, width=1024, height=768, res=100)
  par(mar=margin, xpd=TRUE, xaxs='i')
  total_elements <- length(cpu_cores)
  xlabel <- 'Time'
  ylabel <- 'CPU utilization (%)'
  yrange <- c(0, 100)
  position <- 1
  colors_core <- c('blue', 'red', 'green', 'black', 'yellow', 'gray')
  legend_core <- vector(mode='list')

  # Note: The last element of cpu_core it is date and time.
  # Fist core is handled separately
  plot(cpu_cores[[total_elements]], 100 - cpu_cores[[1]]$Idle,
       type='l', ylim=yrange, col=colors_core[1], cex.lab=1.5, lty=1,
       ylab=ylabel, xlab=xlabel, xaxt='n')
  legend_core[1] <- 'CPU1'
  finish <- total_elements - 1

  if (finish > 1)
  {
    for (position in 2:finish)
    {
      lines(cpu_cores[[total_elements]], 100 - cpu_cores[[position]]$Idle,
            type='l', col=colors_core[position], lwd=1, lty=position)
      legend_core[position] <- paste('CPU', position, sep='')
    }
  }
  # Adjust axis x
  total_samples <- length(cpu_cores[[total_elements]])
  display <- seq(cpu_cores[[total_elements]][1],
                 cpu_cores[[total_elements]][total_samples],
                 length.out=10)
  axis(1, display, format(display, "%H:%M:%S"))
  legend('topleft', inset=c(-0.20,0), legend=c(legend_core), lty=c(1:finish),
          col=c(colors_core[1:finish]))
  dev.off()
  return (0)
}

# Read arguments
pathsArguments <- commandArgs(trailingOnly=TRUE)

# Test if there three argument. If not, return an error.
arguments <- length(pathsArguments)
if (arguments < 2 | arguments > 2)
{
  stop('You have to inform [origin] of file and [destin] of image')
} else if (length(pathsArguments) == 2)
{
  # default output file
  origin <- pathsArguments[1]
  destin <- pathsArguments[2]
}

cpu_data <- load_cpu_data(origin)
plot_cpu_utilization(cpu_data, destin)
